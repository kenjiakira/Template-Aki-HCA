const fs = require('fs');
const path = require('path');

module.exports = {
  name: "thread",
  info: "Th√¥ng b√°o khi nh√≥m thay ƒë·ªïi ch·ªß ƒë·ªÅ, emoji, t√™n, admin ho·∫∑c ·∫£nh", 
  pro: "HNT",

  userCache: new Map(),
  lastApiCall: 0,
  API_COOLDOWN: 2000, 

  nameCache: {},
  nameCachePath: path.join(__dirname, '../database/json/usernames.json'),

  initNameCache: function() {
    try {
      if (fs.existsSync(this.nameCachePath)) {
        this.nameCache = JSON.parse(fs.readFileSync(this.nameCachePath));
      } else {
        if (!fs.existsSync(path.dirname(this.nameCachePath))) {
          fs.mkdirSync(path.dirname(this.nameCachePath), { recursive: true });
        }
        fs.writeFileSync(this.nameCachePath, JSON.stringify({}));
      }
    } catch (err) {
      console.error('Name cache init error:', err);
    }
  },

  saveName: function(userID, name) {
    try {
      this.nameCache[userID] = {
        name: name,
        timestamp: Date.now()
      };
      fs.writeFileSync(this.nameCachePath, JSON.stringify(this.nameCache, null, 2));
    } catch (err) {
      console.error('Name cache save error:', err);
    }
  },

  getUserInfo: async function(api, userID, threadID) {  
    if (!this.nameCache) this.initNameCache();

    if (this.nameCache[userID]) {
      const cached = this.nameCache[userID];
     
      if (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
        return {[userID]: {name: cached.name}};
      }
    }

    const now = Date.now();
    if (now - this.lastApiCall < this.API_COOLDOWN) {
      await new Promise(resolve => setTimeout(resolve, this.API_COOLDOWN));
    }
    
    try {
      const info = await api.getUserInfo(userID);
      this.lastApiCall = Date.now();
      if (info[userID]?.name) {
        this.saveName(userID, info[userID].name);
        return info;
      }
      throw new Error('No name in response');
    } catch (err) {
      console.log(`Failed to get info for ${userID}:`, err);
      
      if (threadID) {  
        try {
          const threadInfo = await api.getThreadInfo(threadID);
          const participant = threadInfo.userInfo?.find(user => user.id === userID);
          if (participant?.name) {
            this.saveName(userID, participant.name);
            return {[userID]: {name: participant.name}};
          }
        } catch (e) {
          console.error('Fallback name fetch failed:', e);
        }
      }

      if (this.nameCache[userID]) {
        return {[userID]: {name: this.nameCache[userID].name}};
      }

      const fallbackName = `Ng∆∞·ªùi d√πng Facebook (${userID})`;
      this.saveName(userID, fallbackName);
      return {[userID]: {name: fallbackName}};
    }
  },

  async tryChangeColor(api, color, threadID) {
    return new Promise((resolve, reject) => {
        api.changeThreadColor(color, threadID, (err) => {
            if (err) reject(err);
            else resolve();
        });
    });
  },

  onEvents: async function({ api, event, Threads }) {
    const { threadID, author, logMessageType, logMessageData } = event;
    
    const getAuthorName = async () => {
      const info = await this.getUserInfo(api, author, threadID);
      return info[author]?.name || "Ng∆∞·ªùi d√πng Facebook";
    };

    if (logMessageType === "log:thread-image") {
      try {
        const authorName = await getAuthorName();
        
        const antiimgPath = path.join(__dirname, '../commands/json/antiimage.json');
        if (fs.existsSync(antiimgPath)) {
          const antiimgData = JSON.parse(fs.readFileSync(antiimgPath));
          
          if (antiimgData[threadID]?.enable) {
           
            await new Promise(resolve => setTimeout(resolve, 1000));

            if (antiimgData[threadID].localPath && fs.existsSync(antiimgData[threadID].localPath)) {
              try {
                const imageStream = fs.createReadStream(antiimgData[threadID].localPath);
                await api.changeGroupImage(imageStream, threadID);
              } catch (localError) {
                console.error('Local image restore error:', localError);
                
                try {
                  const axios = require('axios');
                  const { data } = await axios.get(antiimgData[threadID].imageUrl, { responseType: 'stream' });
                  await api.changeGroupImage(data, threadID);
                } catch (urlError) {
                  console.error('URL image restore error:', urlError);
                  return api.sendMessage("‚ùå Kh√¥ng th·ªÉ kh√¥i ph·ª•c ·∫£nh nh√≥m!", threadID);
                }
              }
            } else {
              try {
                const axios = require('axios');
                const { data } = await axios.get(antiimgData[threadID].imageUrl, { responseType: 'stream' });
                await api.changeGroupImage(data, threadID);
              } catch (error) {
                console.error('Image restore error:', error);
                return api.sendMessage("‚ùå Kh√¥ng th·ªÉ kh√¥i ph·ª•c ·∫£nh nh√≥m!", threadID);
              }
            }
            
            api.sendMessage(
              `‚ö†Ô∏è ${authorName} ƒë√£ c·ªë g·∫Øng ƒë·ªïi ·∫£nh nh√≥m!\n` +
              `üö´ ƒê√£ kh√¥i ph·ª•c v·ªÅ ·∫£nh c≈©!`,
              threadID
            );
            return;
          }
        }

        let msg = `üë• THAY ƒê·ªîI ·∫¢NH NH√ìM\n` +
                 `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
                 `üë§ Ng∆∞·ªùi thay ƒë·ªïi: ${authorName}\n` +
                 `‚è∞ Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}`;
        
        api.sendMessage(msg, threadID);
        
      } catch (error) {
        console.error('Thread Image Update Error:', error);
        api.sendMessage("‚ùå C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t ·∫£nh nh√≥m", threadID);
      }
      return;
    }

    if (logMessageType === "log:thread-admins") {
      try {
        const authorName = await getAuthorName();
        const targetID = logMessageData.TARGET_ID;
   
        const targetInfo = await this.getUserInfo(api, targetID, threadID);
        const targetName = targetInfo[targetID]?.name || "Ng∆∞·ªùi d√πng Facebook";
        
        let msg = `üë• THAY ƒê·ªîI QU·∫¢N TR·ªä VI√äN\n` +
                 `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
                 `üë§ Ng∆∞·ªùi th·ª±c hi·ªán: ${authorName}\n` +
                 `üéØ ƒê·ªëi t∆∞·ª£ng: ${targetName}\n` +
                 `üìù H√†nh ƒë·ªông: ${logMessageData.ADMIN_EVENT === "add_admin" ? "Th√™m Admin" : "G·ª° Admin"}\n` +
                 `‚è∞ Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}`;
                 
        api.sendMessage(msg, threadID);
        return;
      } catch (error) {
        console.error('Admin Update Error:', error);
        api.sendMessage("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ng∆∞·ªùi d√πng", threadID);
      }
    }

    if (logMessageType === "log:thread-name") {
      const antinamePath = path.join(__dirname, '../commands/json/antiname.json');
      if (fs.existsSync(antinamePath)) {
        const antinameData = JSON.parse(fs.readFileSync(antinamePath));
        
        if (antinameData[threadID]?.enable) {
          const oldName = antinameData[threadID].name;
          try {
            await api.setTitle(oldName, threadID);
            const authorName = await getAuthorName();
            
            api.sendMessage(
              `‚ö†Ô∏è ${authorName} ƒë√£ c·ªë g·∫Øng ƒë·ªïi t√™n nh√≥m!\n` +
              `üö´ ƒê√£ kh√¥i ph·ª•c t√™n nh√≥m v·ªÅ: ${oldName}`,
              threadID
            );
            return;
          } catch (error) {
            console.error('Anti-name Error:', error);
          }
        }
      }
    }
    
    if (logMessageType === "log:thread-color" || logMessageType === "log:thread-icon") {
      try {
        const authorName = await getAuthorName();
        
        if (logMessageType === "log:thread-color") {
          const anticolorPath = path.join(__dirname, '../commands/json/anticolor.json');
          if (fs.existsSync(anticolorPath)) {
            const anticolorData = JSON.parse(fs.readFileSync(anticolorPath));
            
            if (anticolorData[threadID]?.enable) {
              await new Promise(resolve => setTimeout(resolve, 2000));

              let success = false;
              const colors = anticolorData[threadID].colors;
              let currentIndex = anticolorData[threadID].currentColorIndex || 0;

              // Try each color in the array until one works
              for (let i = 0; i < colors.length; i++) {
                  const colorIndex = (currentIndex + i) % colors.length;
                  const color = colors[colorIndex];
                  
                  try {
                      await this.tryChangeColor(api, color, threadID);
                      success = true;
                      anticolorData[threadID].currentColorIndex = colorIndex;
                      fs.writeFileSync(anticolorPath, JSON.stringify(anticolorData, null, 4));
                      break;
                  } catch (err) {
                      console.log(`Failed to set color ${color}:`, err);
                      await new Promise(resolve => setTimeout(resolve, 1000));
                      continue;
                  }
              }

              if (success) {
                  api.sendMessage(
                      `‚ö†Ô∏è ${authorName} ƒë√£ c·ªë g·∫Øng ƒë·ªïi m√†u chat!\n` +
                      `üö´ ƒê√£ kh√¥i ph·ª•c v·ªÅ m√†u c≈©!`,
                      threadID
                  );
              } else {
                  throw new Error("All color restoration attempts failed");
              }
              return;
            }
          }

          const oldColor = logMessageData.old_color || "M·∫∑c ƒë·ªãnh";
          const newColor = logMessageData.new_color || "M·∫∑c ƒë·ªãnh";
          
          let msg = `üë• THAY ƒê·ªîI CH·ª¶ ƒê·ªÄ NH√ìM\n` +
                    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
                    `üë§ Ng∆∞·ªùi thay ƒë·ªïi: ${authorName}\n` +
                    `üé® M√†u c≈©: ${oldColor}\n` +
                    `üé® M√†u m·ªõi: ${newColor}\n` +
                    `‚è∞ Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}`;
          
          api.sendMessage(msg, threadID);
        } else if (logMessageType === "log:thread-icon") {
          const oldEmoji = logMessageData.old_emoji || "‚ö™";
          const newEmoji = logMessageData.new_emoji || "‚ö™";
          
          let msg = `üë• THAY ƒê·ªîI EMOJI NH√ìM\n` +
                    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
                    `üë§ Ng∆∞·ªùi thay ƒë·ªïi: ${authorName}\n` +
                    `üòÄ Emoji c≈©: ${oldEmoji}\n` +
                    `üòÄ Emoji m·ªõi: ${newEmoji}\n` +
                    `‚è∞ Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}`;
          
          api.sendMessage(msg, threadID);
        }
        
      } catch (error) {
        console.error('Thread Update Event Error:', error);
        api.sendMessage(
          "‚ùå C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω thay ƒë·ªïi m√†u chat\n" +
          "üí° H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông th·ª≠ l·∫°i sau.", 
          threadID
        );
      }
    }
  }
};
