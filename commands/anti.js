const fs = require('fs');
const path = require('path');

module.exports = {
    name: "anti",
    dev: "HNT",
    usedby: 1,
    cooldowns: 5,
    info: "Qu·∫£n l√Ω c√°c t√≠nh nƒÉng b·∫£o v·ªá nh√≥m",
    usages: "<feature> <on/off>",
    onPrefix: true,

    features: {
        spam: { 
            name: 'antispam', 
            icon: 'üõ°Ô∏è', 
            desc: 'ch·ªëng spam tin nh·∫Øn', 
            detail: '15 tin nh·∫Øn/5 gi√¢y',
            defaultData: { threads: {}, spamData: {} }
        },
        role: { 
            name: 'antirole', 
            icon: 'üëë', 
            desc: 'ch·ªëng ƒë·ªïi quy·ªÅn QTV', 
            detail: 'ch·ªâ admin bot ƒë∆∞·ª£c ph√©p' 
        },
        out: { 
            name: 'antiout', 
            icon: 'üö´', 
            desc: 'ch·ªëng r·ªùi nh√≥m', 
            detail: 't·ª± th√™m l·∫°i khi out' 
        },
        join: { 
            name: 'antijoin', 
            icon: 'üö∑', 
            desc: 'ch·ªëng th√™m th√†nh vi√™n', 
            detail: 't·ª± kick th√†nh vi√™n m·ªõi' 
        },
        nick: { 
            name: 'antinc', 
            icon: 'üìù', 
            desc: 'ch·ªëng ƒë·ªïi bi·ªát danh', 
            detail: 'ch·ªâ QTV ƒë∆∞·ª£c ph√©p' 
        },
        name: { 
            name: 'antiname', 
            icon: '‚úèÔ∏è', 
            desc: 'ch·ªëng ƒë·ªïi t√™n nh√≥m', 
            detail: 'ch·ªâ QTV ƒë∆∞·ª£c ph√©p' 
        },
        avt: { 
            name: 'antiavt', 
            icon: 'üñºÔ∏è', 
            desc: 'ch·ªëng ƒë·ªïi ·∫£nh nh√≥m', 
            detail: 'ch·ªâ QTV ƒë∆∞·ª£c ph√©p' 
        },
        tag: { 
            name: 'antitag', 
            icon: 'üè∑Ô∏è', 
            desc: 'ch·ªëng tag spam', 
            detail: '3 l·∫ßn/24h',
            defaultData: { threads: {}, tagData: {} }
        }
    },

    onLoad: function() {
        const jsonDir = path.join(__dirname, 'json');
        if (!fs.existsSync(jsonDir)) {
            fs.mkdirSync(jsonDir, { recursive: true });
        }

        Object.values(this.features).forEach(feature => {
            const jsonPath = path.join(jsonDir, `${feature.name}.json`);
            if (!fs.existsSync(jsonPath)) {
                fs.writeFileSync(
                    jsonPath, 
                    JSON.stringify(feature.defaultData || {}, null, 4)
                );
            }
        });
    },

    onLaunch: async function({ api, event, target }) {
        const { threadID, senderID } = event;
        
        try {
            const threadsDB = JSON.parse(fs.readFileSync("./database/threads.json", "utf8")) || {};
            const adminConfig = JSON.parse(fs.readFileSync('./admin.json', 'utf8'));
            
            const isAdminBot = adminConfig.adminUIDs.includes(senderID);
            const isGroupAdmin = threadsDB[threadID]?.adminIDs?.some(admin => 
                admin.id === senderID || admin === senderID
            );

            if (!isAdminBot && !isGroupAdmin) {
                return api.sendMessage("‚ö†Ô∏è Ch·ªâ Admin bot ho·∫∑c Qu·∫£n tr·ªã vi√™n nh√≥m m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!", threadID);
            }

            if (!target[0]) {
                let msg = "‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n";
                msg += "     üìå ANTI SYSTEM üìå     \n";
                msg += "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n";
                
                Object.entries(this.features).forEach(([key, value]) => {
                    const status = this.getFeatureStatus(value.name, threadID);
                    msg += `${value.icon} ${key.toUpperCase()}: ${value.desc}\n`;
                    msg += `‚Ü¨ Chi ti·∫øt: ${value.detail}\n`;
                    msg += `‚Ü¨ Tr·∫°ng th√°i: ${status ? "ON ‚úÖ" : "OFF ‚ùå"}\n`;
                    msg += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";
                });
                
                msg += "\nüí° H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:\n";
                msg += "‚å≤ anti <t√≠nh nƒÉng> on/off\n";
                msg += "‚å≤ V√≠ d·ª•: anti spam on\n";
                return api.sendMessage(msg, threadID);
            }

            const feature = target[0].toLowerCase();
            const action = target[1]?.toLowerCase();

            if (feature === 'all' || feature.includes(' ')) {
                const featureList = feature === 'all' ? 
                    Object.keys(this.features) : 
                    feature.split(' ').filter(f => this.features[f]);

                if (!action || !["on", "off"].includes(action)) {
                    return api.sendMessage("‚ö†Ô∏è Vui l√≤ng s·ª≠ d·ª•ng: anti all on/off ho·∫∑c anti spam avt on/off", threadID);
                }

                const isEnable = action === "on";
                let updatedFeatures = [];

                for (const feat of featureList) {
                    const featureConfig = this.features[feat];
                    try {
                        const threadInfo = await api.getThreadInfo(threadID);
                        await this.updateFeature(featureConfig.name, threadID, isEnable, threadInfo || {});
                        updatedFeatures.push(featureConfig.desc);
                    } catch (error) {
                        console.error(`Anti ${feat} update error:`, error);
                        await this.updateFeature(featureConfig.name, threadID, isEnable, {});
                    }
                }

                return api.sendMessage(
                    `‚úÖ ƒê√£ ${isEnable ? 'b·∫≠t' : 't·∫Øt'} c√°c t√≠nh nƒÉng b·∫£o v·ªá:\n${updatedFeatures.map(desc => `‚Ä¢ ${desc}`).join('\n')}`,
                    threadID
                );
            }

            if (!this.features[feature]) {
                return api.sendMessage("‚ö†Ô∏è T√≠nh nƒÉng kh√¥ng h·ª£p l·ªá!", threadID);
            }

            if (!action || !["on", "off"].includes(action)) {
                return api.sendMessage("‚ö†Ô∏è Vui l√≤ng ch·ªçn on ho·∫∑c off!", threadID);
            }

            const featureConfig = this.features[feature];
            const isEnable = action === "on";
            
            try {
                const threadInfo = await api.getThreadInfo(threadID);
                await this.updateFeature(featureConfig.name, threadID, isEnable, threadInfo || {});
            } catch (error) {
                console.error(`Anti ${feature} update error:`, error);
                await this.updateFeature(featureConfig.name, threadID, isEnable, {});
            }

            return api.sendMessage(
                `${featureConfig.icon} ${featureConfig.desc}\n` +
                `‚Ü¨ Tr·∫°ng th√°i: ${isEnable ? "ON ‚úÖ" : "OFF ‚ùå"}\n` +
                `‚Ü¨ Chi ti·∫øt: ${featureConfig.detail}`,
                threadID
            );

        } catch (error) {
            console.error(`Anti command error:`, error);
            return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh!", threadID);
        }
    },

    getFeatureStatus: function(feature, threadID) {
        try {
            const jsonPath = path.join(__dirname, 'json', `${feature}.json`);
            const data = JSON.parse(fs.readFileSync(jsonPath));
                    lastUpdate: Date.now()
            
            if (feature === 'antiavt') {
                return data[threadID]?.enable || false;
            }
            
            if (feature === 'antiout' || feature === 'antijoin' || feature === 'antiname') {
                if (feature === 'antiname') {
                    return data[threadID]?.enable || false;
                }
                return data[threadID] || false;
            }
            
            return data.threads?.[threadID] || false;
        } catch {
            return false;
        }
    },

    updateFeature: async function(feature, threadID, isEnable, threadInfo) {
        const jsonPath = path.join(__dirname, 'json', `${feature}.json`);
        let data = {};

        try {
            data = JSON.parse(fs.readFileSync(jsonPath));
        } catch {
            data = feature === 'antispam' ? { threads: {}, spamData: {} } :
                   feature === 'antitag' ? { threads: {}, tagData: {} } : {};
        }

        switch (feature) {
            case 'antiout':
            case 'antijoin':
                data[threadID] = isEnable;
                break;

            case 'antiname':
                data[threadID] = {
                    enable: isEnable,
                    name: threadInfo.threadName,
                    lastUpdate: Date.now()
                };
                break;

            case 'antiavt':
                if (isEnable && threadInfo.imageSrc) {
                    const imagePath = await this.downloadImage(threadInfo.imageSrc, threadID);
                    data[threadID] = {                        enable: true,
                        imageUrl: threadInfo.imageSrc,
                        localPath: imagePath,
                        lastUpdate: Date.now()
                    };
                } else {
                    data[threadID] = { enable: false };
                }
                break;

            default:
                if (!data.threads) data.threads = {};
                data.threads[threadID] = isEnable;
        }

        fs.writeFileSync(jsonPath, JSON.stringify(data, null, 4));
    },

    downloadImage: async function(url, threadID) {
        const cacheDir = path.join(__dirname, 'cache');
        if (!fs.existsSync(cacheDir)) {
            fs.mkdirSync(cacheDir);
        }

        const imagePath = path.join(cacheDir, `thread_${threadID}.jpg`);
        
        try {
            const axios = require('axios');
            const response = await axios.get(url, { responseType: 'stream' });
            const writer = fs.createWriteStream(imagePath);
            response.data.pipe(writer);
            
            return new Promise((resolve, reject) => {
                writer.on('finish', () => resolve(imagePath));
                writer.on('error', reject);
            });
        } catch (err) {
            console.error('Image download error:', err);
            return null;
        }
    }
};